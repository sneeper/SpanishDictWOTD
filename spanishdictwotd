#!/usr/local/bin/python3

import os
import sys
import certifi
import requests
import discord
import threading
import asyncio
import argparse
import urllib.parse
import logging

from bs4 import BeautifulSoup
from discord.ext import tasks
from datetime import datetime, time, timezone
from zoneinfo import ZoneInfo
from pathlib import Path

# ── LOGGING ───────────────────────────────────────────────────────────────────

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s'
)

# ── FUNCTIONS ────────────────────────────────────────────────────────────────

def load_token():
    """Load the Discord bot token from an environment variable or a .token file."""
    token = os.getenv("DISCORD_TOKEN")
    if token:
        return token.strip()
    try:
        here = os.path.abspath(os.path.dirname(__file__))
        with open(os.path.join(here, ".token"), "r") as f:
            return f.read().strip()
    except FileNotFoundError:
        logging.error("❌ No DISCORD_TOKEN env var and no .token file found.")
        sys.exit(1)

def load_history(history_file):
    """Load a set of previously sent words from the history file."""
    if not history_file.exists(): return set()
    return {l.strip() for l in history_file.read_text().splitlines() if l}

def save_word(word, history_file):
    """Append a new word to the history file."""
    with history_file.open("a") as f:
        f.write(f"{word}\n")

def fetch_wotd():
    """Scrape the SpanishDict Word of the Day page and return a Discord embed and word."""
    url = 'https://www.spanishdict.com/wordoftheday'
    logging.info(f"Fetching WOTD from: {url}")
    try:
        resp = requests.get(url)
        resp.raise_for_status()
    except Exception as e:
        logging.error(f"Error fetching WOTD: {e}")
        return None, None

    soup = BeautifulSoup(resp.text, 'html.parser')

    word_tag = soup.find('h3')
    word = word_tag.get_text(strip=True) if word_tag else '—'
    def_tag = word_tag.find_next_sibling() if word_tag else None
    definition = def_tag.get_text(strip=True) if def_tag else '—'

    example = None
    ex_header = soup.find(string=lambda t: 'EXAMPLES' in t.upper())
    if ex_header:
        ex_tag = ex_header.find_parent().find_next_sibling()
        raw = ex_tag.get_text(strip=True) if ex_tag else ""
        if '—' in raw:
            spanish, english = map(str.strip, raw.split('—', 1))
        else:
            spanish, english = raw, ""
        spanish = f"*{spanish.replace(word, f'**{word}**')}*"
        english = english.replace(definition, f"**{definition}**")
        example = f"{spanish}\n{english}"

    embed = discord.Embed(
        title=f"\U0001F4D6 Word of the Day: **{word}**",
        url=f"https://www.spanishdict.com/translate/{urllib.parse.quote(word)}",
        description=f"*Definition:* {definition}"
    )
    if example:
        embed.add_field(name="Example", value=example, inline=False)

    return embed, word

async def do_send(client, target_id, target_type, history_file):
    """Fetch the word of the day and send it to the configured Discord channel/thread."""
    embed, word = fetch_wotd()
    if not word:
        return
    history = load_history(history_file)
    logging.info(f"Attempting to send WOTD: {word!r}")
    if word in history:
        logging.info(f" → Skipped: {word!r} was already sent.")
        return
    target = client.get_channel(target_id)
    if not target:
        logging.error(f" → ERROR: {target_type} {target_id} not found.")
        return
    await target.send(embed=embed)
    logging.info(f" → Sent: {word!r} to {target_type} {target_id}")
    save_word(word, history_file)

def start_stdin_listener(client, target_id, target_type, history_file):
    """Start a background thread to listen for the 'force' command on stdin."""
    def _stdin_loop():
        while True:
            try:
                line = input().strip()
                if line.lower() == "force":
                    asyncio.run_coroutine_threadsafe(do_send(client, target_id, target_type, history_file), client.loop)
            except EOFError:
                break
    t = threading.Thread(target=_stdin_loop, daemon=True)
    t.start()

# ── MAIN ───────────────────────────────────────────────────────────────

def main():
    """Main function to initialize configuration and run the bot."""
    

    parser = argparse.ArgumentParser(
        description="SpanishDict WOTD bot — daemon or one-shot"
    )
    parser.add_argument("--once", "-o", action="store_true", help="Send WOTD once on startup.")
    target = parser.add_mutually_exclusive_group(required=True)
    target.add_argument("--channel-id", "-c", type=int, help="Discord channel ID to post into")
    target.add_argument("--thread-id", "-t", type=int, help="Discord thread ID to post into")
    parser.add_argument("--utc-time", "-u", metavar="HH:MM", help="Daily send time in UTC (e.g. 16:30)")
    args = parser.parse_args()

    if args.channel_id:
        target_id = args.channel_id
        target_type = "channel"
    else:
        target_id = args.thread_id
        target_type = "thread"

    if args.utc_time:
        h, m = map(int, args.utc_time.split(":", 1))
        schedule_time = time(h, m, tzinfo=timezone.utc)
    else:
        schedule_time = time(9, 0, tzinfo=timezone.utc)  # 1 AM PT

    token = load_token()
    history_file = Path(__file__).parent / "sent_wotd.txt"
    os.environ['SSL_CERT_FILE'] = certifi.where()

    intents = discord.Intents.default()
    client = discord.Client(intents=intents)

    @client.event
    async def on_ready():
        """Event handler for when the bot successfully logs in."""
        logging.info(f"Logged in as {client.user} (ID: {client.user.id})")
        for guild in client.guilds:
            logging.info(f"Server: {guild.name} (ID: {guild.id})")
            for channel in guild.text_channels:
                logging.info(f"  #{channel.name}: {channel.id}")
        if args.once:
            logging.info("One-shot mode. Sending now and exiting.")
            await do_send(client, target_id, target_type, history_file)
            await client.close()
        else:
            logging.info(f"Daemon mode. Waiting until {schedule_time} UTC.")
            logging.info("Type ‘force’ + Enter to send immediately.")
            daily_wotd.start()
            start_stdin_listener(client, target_id, target_type, history_file)

    @tasks.loop(time=schedule_time)
    async def daily_wotd():
        """Scheduled task to send the WOTD daily."""
        await do_send(client, target_id, target_type, history_file)

    client.run(token)

if __name__ == "__main__":
    main()
  

